<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Integer实现原理及缓存机制]]></title>
    <url>%2F2019%2F01%2F06%2FInteger%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Java涉及知识点 装箱和拆箱 反射及设置对象访问权限原理 函数参数的值传递和引用传递 Integer原理及缓存机制 实现一个函数来交换参数的两个值 1. 装包和拆包java提供的基本类型以及其对于的包装类型 基本类型 对于包装类型 byte Byte char Character short Short int Integer long Long float Float double Double void Void 以Integer为例子介绍装箱和拆箱：” 装箱存在的情况：int 赋值给Integer 即基本类型赋值给包装类型时 Integer i = 1; 等价于 Integer i = Integer.valueOf(1); java自动完成装箱操作 拆箱存在的情况：int与Integer比较 及基本类型和包装类型比较时 12345Integer i = new Integer(1);int j = 1;i == j //等价于 i.intValue() == j i对象会自动拆箱int类型和j进行比较 2. 反射及设置对象访问权限原理JAVA反射机制是运行过程中，任意实体都可可以知道这个实体类的对象的所有方法和属性信息对于任何对象都可以调用它的任意方法和属性，这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 这里我们反射的目标是修改某个类的private属性值。以Integer为例： 1234567891011//获取Integer类对象的方式//Class clazz = Class.forName(&quot;java.lang.Integer&quot;);Class clazz = Integer.class;//获取Integer类中私有属性value的域 getDeclaredField获取类本身对应的所有访问//权限的属性 getField获取类以及父类所有的public属性Field field = clazz.getDeclaredField(&quot;value&quot;); field.setAccessible(true); //设置private域访问权限Integer a = 1;field.set(a, 2);//将a 对象中的value属性设置为2 对象访问权限原理 反着访问对象的原理主要看Field类的setAccessible和set即可。一个设置域的可见性，一个设置属性值。 File类声明：public finalclass Field extends AccessibleObject implements Member123456789101112131415161718//setAccessible源码 父类AccessibleObject的方法 public void setAccessible(boolean flag) throws SecurityException &#123; SecurityManager sm = System.getSecurityManager(); if (sm != null) sm.checkPermission(ACCESS_PERMISSION); setAccessible0(this, flag);//前面是一安全管理器判断，这里才是真正设置的地方 &#125; private static void setAccessible0(AccessibleObject obj, boolean flag) throws SecurityException &#123; if (obj instanceof Constructor &amp;&amp; flag == true) &#123; Constructor&lt;?&gt; c = (Constructor&lt;?&gt;)obj; if (c.getDeclaringClass() == Class.class) &#123; throw new SecurityException(&quot;Cannot make a java.lang.Class&quot; + &quot; constructor accessible&quot;); &#125; &#125; obj.override = flag; //field父类中的override属性设置为flag，也就是我们设置的true &#125; 123456789101112//set Feild中的set方法public void set(Object obj, Object value) throws IllegalArgumentException, IllegalAccessException &#123; if (!override) &#123;//同样是判断field父类中的override，为true则不检查对象访问权限 直接设值 if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, obj, modifiers); &#125; &#125; getFieldAccessor(obj).set(obj, value); &#125; 3. 函数参数的值传递和引用传递java中的函数参数传递分为值传递和引用传递。实际上都可以认为是值传递（引用传递实质传递的是引用的值（可以看作C++中指针，存放地址的变量），也同样需要拷贝副本，不过不是对象的副本，而且存放对象地址的变量的副本）。 值传递：针对于基本数据类型 引用传递：针对于对象 1234567891011int i = 1void add1 (int i)&#123;//值传递 在i参数传入的时候 实际上会拷贝i的一副本，然后在函数中进行操作 i++;//实际操作的是i的副本，所以函数外部的i变量不受影响&#125;System.out.println(i);//输出为1Integer j = 1;// j = Integer.valueOf(1)void add2 (Integer j)&#123;//引用传递 在j参数传入的时候 实际上会拷贝j对象的引用 然后传入函数中进行操作 j++; //装箱和拆箱的等价？ j=j+1 j = Integer.valueOf(j.intValue()+1) 实际上是副本j引用指向了新的Integer对象，外面的j引用还是指向原来的对象 &#125;System.out.println(j);//输出同样为1 4. Integer原理及缓存机制Integer是int基本数据类型的包装类，无非是在int基本类型的基础上增加了一些操作和其他属性。 Integer的实际对应int值是通过intValue()方法获取的，源码如下： 1234private final int value;//对应int基本类型的数值 是一个常量整型public int intValue() &#123; return value;&#125; 前面说过的装箱用到的一个方法是valueOf(),让我们看看源码： 123456//可以看到传入的i 先和IntegerCache比较 在IntegerCache中则返回IntegerCache中的Integer不存在则new一个Integer对象 public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; IntegerCache实现如下： 12345678910111213141516171819202122232425262728293031323334//IntegerCache是个Integer的内部类，在类加载的时候创建了256个缓存Integer对象，范围-128至127 private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125; 知道Integer缓存的存在，下面我们看看下面的几个例子： 注：== 对象比较比较的是对象的引用是否相等 equals则根据对象内部的实现情况进行比较 123Integer i = 1; //i = Integer.valueOf(1) 取缓存对象 IntegerCache.cache[129]Integer j = 1; //j = Integer.valueOf(1) 取缓存对象 IntegerCache.cache[129]System.out.println(i == j);//输出true i 和j指向同一个对象 123Integer i = 1; //i = Integer.valueOf(1) 取缓存对象 IntegerCache.cache[129]Integer j = new Integer(1); // 新创建一个对象System.out.println(i == j);//输出false i 和j指向的不是同一个对象 123Integer i = 128; //i = Integer.valueOf(128) 不在缓存访问内 new Integer(128)Integer j = 128; //j = Integer.valueOf(128) 不在缓存访问内 new Integer(128)System.out.println(i == j); //输出false i 和j指向的不是同一个对象 所以Integer对象在比较是否相等的时候 不要用 == 用equals Integer内部实现了自己用equals,源码如下：123456public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; return value == ((Integer)obj).intValue(); &#125; return false; &#125; 5. 实现一个函数来交换参数的两个值前面已经补充了一些Java的相关知识点了，现在我们就来实现一个函数来交换参数的两个值 1234567891011121314151617181920212223242526272829303132333435363738public class Main &#123; static void swap1(Integer a, Integer b)&#123; //第3节已经说明了 这里函数中只是操作的引用副本,是不影响函数外a,b的变化的 Integer temp = a; a = b; b = temp; &#125;//输出a=1 b=2 static void swap2(Integer a, Integer b) throws NoSuchFieldException, IllegalAccessException &#123;//通过反射机制来修改引用指向对象的value值即改改变函数外a，b中的value数属性 Field field = Integer.class.getDeclaredField(&quot;value&quot;);//value是private final field.setAccessible(true);//绕过安全检查 //temp = 1 temp -&gt;Integer.valueOf(a.intValue()) -&gt; Integer.valueOf(1) -&gt;IntegerCache.cache[129] Integer temp = a.intValue(); //public void set(Object obj, Object value) //a.value-&gt;Integer.valueOf(b.intValue()).intValue(); 修改a指向对象中value值为2 //a指向的是缓存中的IntegerCache.cache[129] 所以IntegerCache.cache[129] //中的value被修改成2 field.set(a, b.intValue()); //b -&gt; IntegerCache.cache[130] //b.value-&gt;IntegerCache.cache[129].value 所以 IntegerCache.cache[130] IntegerCache.cache[129] value都是2 所以a b中value 都是2 field.set(b, temp); &#125;//输出a=2 b=2 static void swap3(Integer a, Integer b) throws NoSuchFieldException, IllegalAccessException &#123; Field field = Integer.class.getDeclaredField(&quot;value&quot;); field.setAccessible(true);//绕过安全检查 Integer temp = new Integer(a.intValue());//和swap2唯一区区别就在这一行 field.set(a, b.intValue()); //a-&gt;Integer.valueOf(b.intValue()).intValue(); field.set(b,temp);//b.value-&gt;new Integer(a.intValue()).intValue() 而不是修改成IntegerCache.cache[129].intValue(); &#125;//输出a=2 b=1 但是存在一个问题就是同样修改了IntegerCache中缓存值 后续存在隐患 public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123; Integer a = 1, b = 2; //装箱操作 等价于 Integer a = Integer.valueOf(1); Integer b = Integer.valueOf(2); swap1(a, b); System.out.println(&quot;a=&quot;+a+&quot; b=&quot;+b);//输出a=1 b=2 &#125;&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程（四）——synchronized同步处理关键字]]></title>
    <url>%2F2018%2F04%2F06%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94synchronized%E5%90%8C%E6%AD%A5%E5%A4%84%E7%90%86%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[这段时间事情比较多，终于闲下来有时间继续来完成Java多线程系列的文章。多线程是很多初级开发人员惧怕的内容，我不断尝试各种学习方法去来深刻理解多线程的相关知识，但是有关多线程编程的书籍大部分更偏理论，对于我们这些初级开发人员来说只能是越看越逃避，所以我决心把我所了解的相关Java多线程的知识点总结分享出来，可能这些内容不能适合每个读者，但是对大家有一点帮助我都会继续坚持下去。 多线程带来的问题多线程的存在大大提高了程序对计算机的利用率，随之而来的却是开发上的不便以及调试的难度。为什么这么说呢？大家都知道，多个线程同时执行无法避免对相同资源的竞争，这种竞争的结果一般是不可预期的。如果想让多个线程同时执行并且按照我们开发人员所规定的去执行，那就需要一些东西来约束它。当然，这也是笔者认为多线程最重要，最难的一个点。 synchronized同步关键字synchronized是java提供的一个同步处理的关键字，可以保证同一时刻只有一个线程能够进入该方法（代码块）。synchronized有三种使用方式：修饰实例方法、修饰静态方法、同步代码块。 synchronized修饰实例方法： 修饰实例方法是对象级锁，多个线程执行同一个对象中被 synchronized的方法时同时只有一个线程能够获取对象锁，执行方法，其他线程等待。12345678910111213141516171819202122232425262728293031323334class ThreadTest implements Runnable&#123; public static int i = 0; /** * synchronized 修饰实例方法 */ public synchronized void increase()&#123; i++; &#125; @Override public void run() &#123; for(int j=0;j&lt;1000000;j++)&#123; increase(); &#125; &#125;&#125;public class Main &#123; public static void main(String []args) throws Exception&#123; ThreadTest instance=new ThreadTest(); Thread t1=new Thread(instance); Thread t2=new Thread(instance); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(ThreadTest.i); &#125;&#125;结果为2000000 i++并不是原子操作，而是首先读取i，然后进行++，最后将算出的值赋值给i，所以当多个线程同时进行i++操作时结果是不预期的，我们这里通过synchronized修饰increase方法保证increase方法的原子性，从而保证某个线程在进行i++操作的时候，其他线程是无法进行i++操作的。 synchronized修饰静态方法： 修饰静态方法是当前类class对象锁，多个线程执行同一类中被 synchronized的静态方法时同时只有一个线程能够获取当前类的class对象锁，执行方法，其他线程等待。 123456789101112131415161718192021222324252627282930313233class ThreadTest implements Runnable&#123; public static int i = 0; /** * synchronized 修饰实例方法 这里将方法修改为了static方法 */ public static synchronized void increase()&#123; i++; &#125; @Override public void run() &#123; for(int j=0;j&lt;1000000;j++)&#123; increase();//这里调用的方法是属于ThreadTest类的静态方法 &#125; &#125;&#125;public class Main &#123; public static void main(String []args) throws Exception&#123; ThreadTest instance=new ThreadTest(); Thread t1=new Thread(instance); Thread t2=new Thread(instance); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(ThreadTest.i); &#125;&#125;结果还是为2000000 synchronized修饰同步代码块： 修饰同步代码块是对代码块括号中的对象进行锁定，多个线程执行同一个被 synchronized的同步代码块时同时只有一个线程能够获取代码块括号中的对象锁，执行代码块内容，其他线程等待。 1234567891011121314151617181920212223242526272829303132333435363738394041class ThreadTest implements Runnable&#123; public static int i = 0; public static int y = 0; public Object lock = new Object(); /** * synchronized 修饰实例方法 */ public void increase()&#123; y++;//未被同步修饰，线程不安全 synchronized (lock)&#123;//lock为代码块对象锁 i++; &#125; &#125; @Override public void run() &#123; for(int j=0;j&lt;1000000;j++)&#123; increase(); &#125; &#125;&#125;public class Main &#123; public static void main(String []args) throws Exception&#123; ThreadTest instance=new ThreadTest(); Thread t1=new Thread(instance); Thread t2=new Thread(instance); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(&quot;x=&quot;+ThreadTest.i); System.out.println(&quot;y=&quot;+ThreadTest.y); &#125;&#125;结果：x=2000000y=1999465 由结果可知，被synchronized修饰的代码块保证了多线程通知访问同时只有一个线程能够进入代码块中，保证了i被多线程处理的安全，y则在多线程处理过程中出现了不可预期的结果。 总结归纳：synchronized虽然有3种使用方式，但是总的来说synchronized都是控制对象的lock和unlock操作。一个线程取得被synchronized修饰的方法（实例或者静态）/代码块的执行资源时，控制的对象进行被锁定，然后执行具体内容，结束时对象解锁，其他线程即可竞争从而执行相关方法/代码块。]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring实现统一捕获接口层异常与邮件警报]]></title>
    <url>%2F2018%2F01%2F06%2FSpring%E5%AE%9E%E7%8E%B0%E7%BB%9F%E4%B8%80%E6%8D%95%E8%8E%B7%E6%8E%A5%E5%8F%A3%E5%B1%82%E5%BC%82%E5%B8%B8%E4%B8%8E%E9%82%AE%E4%BB%B6%E8%AD%A6%E6%8A%A5%2F</url>
    <content type="text"><![CDATA[Java中提供的try{}catch{}finally{}来进行异常捕获，然后当系统业务复杂，代码量则多，为了排除系统错误，我们一般在接口层进行异常捕获，捕获到异常时打印日志，通过日志的方式来排除错误。系统越复杂，接口数量越多，如果我们对所有接口都try{}catch{}的话，那么工作量不仅会很大，以后系统维护难度也会变大。然后SpringMvc在框架层提供给了一种接口层统一处理异常的方法。 @ExceptionHandler：统一处理某一类异常，从而能够减少代码重复率和复杂度。 123456789101112131415161718192021222324public abstract class AbstractController &#123; protected Logger log = LoggerFactory.getLogger(this.getClass()); @ExceptionHandler @ResponseBody public String handleException(HttpServletRequest request, HttpServletResponse response, Exception ex)&#123; if(!(ex instanceof NoNeedHandlerException))&#123; log.error(&quot;&#123;&#125;:\n接口参数：&#123;&#125;\n&#123;&#125;&quot;, request.getRequestURI(), JSONObject.toJSONString(request.getParameterMap()),CommonMail.getFromException(ex)); MonitorInfo monitorInfo = new MonitorInfo(); monitorInfo.setMethodName(request.getRequestURI()); monitorInfo.setParams(request.getParameterMap()); monitorInfo.setException(ex); ExceptionMonitorHelper.monitor(monitorInfo); &#125;else&#123; log.info(&quot;&#123;&#125;:\n接口参数：&#123;&#125;\n&#123;&#125;&quot;, request.getRequestURI(), JSONObject.toJSONString(request.getParameterMap()), ex.getMessage()); &#125; if (ex instanceof HandlerException)&#123; HandlerException exception = (HandlerException)ex; return FmtResult(false, exception.getExceptionCode(), exception.getMessage(), &quot;&quot;); &#125; return FmtResult(false, ResultCode.CODE_ERROR, ResultCode.ERROR_MESSAGE, &quot;&quot;); &#125; &#125; 只需要在handleException对异常进行进行处理即可，这样接口层的异常全部在这个地方统一处理，开发成本和维护成本大大减低。 邮件监控与警报对于一些异常信息，一般都是通过打印日志的方式来记录，通过日志的方式去追溯错误。但是日志很多（尤其是日志打印不规范），很难定位，日志的及时性差，并不能及时通知到开发和运维人员线上错误，尤其是一些线上严重bug。在这里可以通过邮件警报的方式来对系统进行监控。具体实现如下：1234567891011121314151617181920212223242526272829303132333435/** * ZSQ 监控信息类 */public class MonitorInfo &#123; private String methodName; private Map&lt;String, ?&gt; params; private Exception exception; public String getMethodName() &#123; return methodName; &#125; public void setMethodName(String methodName) &#123; this.methodName = methodName; &#125; public Map&lt;String, ?&gt; getParams() &#123; return params; &#125; public void setParams(Map&lt;String, ?&gt; params) &#123; this.params = params; &#125; public Exception getException() &#123; return exception; &#125; public void setException(Exception exception) &#123; this.exception = exception; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * ZSQ 2018年4月8日14:39:51 * 异常监控类 */public class ExceptionMonitorHelper &#123; private static final Logger logger = LoggerFactory.getLogger(ExceptionMonitorHelper.class); private static final LinkedBlockingQueue&lt;MonitorInfo&gt; queue = new LinkedBlockingQueue&lt;&gt;(0xfff8); private Thread monitorThread; private volatile boolean isStop = false; public static String ENVIROMENT = null; public void start()&#123; monitorThread = new Thread(new Runnable() &#123; @Override public void run() &#123; while (!isStop) &#123; try &#123; //可以调用queue.drainTo来批量处理异常信息，提升读取速率，减少加锁和释放锁的次数 MonitorInfo moniterInfo = queue.take(); if (!(moniterInfo.getException() instanceof NoNeedHandlerException)) &#123; logger.debug(&quot;接口处理错误：&#123;&#125;，&#123;&#125;&quot;, JSONObject.toJSONString(moniterInfo), moniterInfo.getException()); if (DEV_EMAILS != null) &#123; CommonMail.sendCodeWarnEmail(ENVIROMENT , moniterInfo, ExceptionLevel.SERIOUS); &#125; &#125; &#125; catch (Exception e) &#123; logger.error(&quot;exception monitor error &#123;&#125;&quot;, e); &#125; &#125; &#125; &#125;); monitorThread.setDaemon(true);//设置为守护线程 主线程退出时即退出 monitorThread.start(); logger.info(&quot;exception monitor start&quot;); &#125; public void stop()&#123; isStop = true; monitorThread.interrupt(); try &#123; monitorThread.join(); &#125; catch (InterruptedException e) &#123; logger.error(e.getMessage(), e); &#125; &#125; public static void monitor(MonitorInfo failInfo)&#123; try &#123; queue.put(failInfo); &#125; catch (InterruptedException e) &#123; logger.error(&quot;exception monitor put error&#123;&#125;&quot;, e); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/***邮件工具类**/public class CommonMail &#123; private static final String NAME = &quot;网&quot;; private static final String USERNAME = &quot;system@qq.com&quot;; private static final String PASSWD = &quot;Qi123456&quot;; private static String MAILHOST = &quot;smtp.exmail.qq.com&quot;;// 发送邮件的主机 private static int SMTPPORT = 465; private static boolean TLS = true; private static boolean DEBUG = true; private static boolean SSL = true; //开发者邮箱配置 private static String DEV_USERNAME; private static String DEV_PASSWD; private static String DEV_NAME; public static String []DEV_EMAILS; static &#123; MAILHOST = ConfigPropertyConfigurer.getContextProperty(&quot;mail.mailhost&quot;) == null ? &quot;smtp.exmail.qq.com&quot; : ConfigPropertyConfigurer.getContextProperty(&quot;mail.mailhost&quot;); SMTPPORT = ConfigPropertyConfigurer.getContextProperty(&quot;mail.smtpport&quot;) == null ? 465 : Integer.parseInt( ConfigPropertyConfigurer.getContextProperty(&quot;mail.smtpport&quot;)); TLS = ConfigPropertyConfigurer.getContextProperty(&quot;mail.tls&quot;) == null ? true : Boolean.parseBoolean(ConfigPropertyConfigurer.getContextProperty(&quot;mail.tls&quot;)); DEBUG = ConfigPropertyConfigurer.getContextProperty(&quot;mail.debug&quot;) == null ? false : Boolean.parseBoolean(ConfigPropertyConfigurer.getContextProperty(&quot;mail.debug&quot;)); SSL = ConfigPropertyConfigurer.getContextProperty(&quot;mail.ssl&quot;) == null ? false : Boolean.parseBoolean(ConfigPropertyConfigurer.getContextProperty(&quot;mail.ssl&quot;)); DEV_USERNAME = ConfigPropertyConfigurer.getContextProperty(&quot;dev.mail.username&quot;); DEV_PASSWD = ConfigPropertyConfigurer.getContextProperty(&quot;dev.mail.password&quot;); DEV_NAME = ConfigPropertyConfigurer.getContextProperty(&quot;dev.mail.name&quot;); DEV_EMAILS = ConfigPropertyConfigurer.getContextProperty(&quot;dev.mail.receivers&quot;).split(&quot;,&quot;); &#125; public static void sendDevEmail(String[] receivers, String subject, String msg)&#123; System.setProperty(&quot;java.net.preferIPv4Stack&quot;, &quot;true&quot;); final SimpleEmail email = new SimpleEmail(); email.setTLS(TLS); email.setDebug(DEBUG); email.setSSL(SSL); email.setHostName(MAILHOST); email.setSmtpPort(SMTPPORT); email.setAuthenticator(new DefaultAuthenticator(DEV_USERNAME, DEV_PASSWD)); try &#123; email.setFrom(DEV_USERNAME, DEV_NAME); for(String receiver:receivers)&#123; email.addTo(receiver); &#125; email.setCharset(&quot;GB2312&quot;); email.setSubject(subject); email.setMsg(msg); new Thread()&#123; public void run() &#123; try &#123; email.send(); &#125; catch (EmailException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125; catch (EmailException e) &#123; e.printStackTrace(); &#125; &#125; public static void sendCodeWarnEmail(final String subject, final String msg, int type)&#123; String sub = &quot;系统警报&quot;; if(1 == type)&#123; sub += &quot;严重错误&quot;; &#125;else if(2 == type)&#123; sub += &quot;普通错误&quot;; &#125;else if(3 == type)&#123; sub += &quot;非预期结果&quot;; &#125; sub += subject; final String tsub = sub; sendDevEmail(DEV_EMAILS, tsub, msg); &#125; public static void sendCodeWarnEmail(String enviroment, MonitorInfo monitorInfo, int type)&#123; String subject = &quot;环境：&quot;+(StringUtils.isBlank(enviroment)?&quot;正式&quot;:enviroment)+&quot;\n&quot;+ &quot;方法名称：&quot;+monitorInfo.getMethodName(); String msg =&quot;方法参数：\n&quot;; msg += (JSON.toJSON(monitorInfo.getParams())+&quot;\n&quot;); msg += &quot;异常信息:\n&quot;; msg += CommonMail.getFromException(monitorInfo.getException()); CommonMail.sendCodeWarnEmail(subject, msg, type); &#125; public static String getFromException(Exception e)&#123; StringWriter sw = new StringWriter(); e.printStackTrace(new PrintWriter(sw, true)); String str = sw.toString(); return str; &#125; &#125; 笔者只是抛砖引玉，大家有更好的方案或优化方法可以提出来，共同学习进步！！！Thank you！！！]]></content>
      <categories>
        <category>Spring</category>
        <category>异常监控</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程（三）——手动实现Future模式]]></title>
    <url>%2F2017%2F08%2F13%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0Future%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在上一章节中向大家介绍了Java为我们提供的Future工具，为了深入了解此模式，本章节将带大家手动来实现future模式。 future模式：使用多线程的目的是为了充分利用计算机资源，来减少处理时间，这必然导致多线程的执行是异步的。然而很多场景下我们需要得到线程执行结果，那么如何来实现呢？future模式提供给我们一种方案，即客户端发送请求，服务端线程启动后就直接返回结果data（并没有真正的结果数据），等服务端处理完成后将线程执行结果放到结果data中，这样客户端即可获取线程执行结果。 序列图： 如果大家感觉这么描述还不够清晰，那么让我们看下到底是如何实现的吧！ 首先，我们需要一个Data类来存放线程执行返回的结果： 123456789101112131415161718192021222324252627public class Data&lt;T&gt; &#123; //存储结果数据 private T data; //结果是否已经准备好 private boolean isReady = false; public synchronized T getData() &#123; if (!isReady) &#123;//结果还没获取到 try &#123; this.wait();//等待获取结果 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; return data; &#125; public synchronized void setData(T data) &#123; if(isReady)//已经设置了结果数据 return; this.data = data; this.isReady = true; this.notifyAll();//通知其他线程执行 即通知客户端获取线程执行结果 &#125;&#125; 实现一个Task类用于表示任务处理： 123 public abstract class Task&lt;T&gt;&#123; public abstract T call();&#125; 123456789101112131415161718import java.util.Random;public class SumTask extends Task&lt;Integer&gt;&#123; @Override public Integer call() &#123; System.out.println(&quot;部门：&quot;+ Thread.currentThread().getId()+&quot;正在计算工资&quot;); Random random = new Random(); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;//模拟工资计算耗时 Integer sum = random.nextInt(100000); System.out.println(&quot;部门：&quot;+ Thread.currentThread().getId()+&quot;计算完成。结果：&quot;+sum); return sum; &#125;&#125; 实现一个Service来实现业务的处理： 123456789101112131415161718public class Service&lt;T&gt; implements Runnable&#123; private Task&lt;T&gt; task; private Data&lt;T&gt; data = new Data&lt;T&gt;(); @Override public void run() &#123; T t = task.call(); data.setData(t); &#125; public Data&lt;T&gt; submitTask(Task&lt;T&gt; task) &#123; this.task = task; new Thread(this).start(); return data; &#125;&#125; 实现一个Main执行类模拟客户段请求：123456789101112131415161718192021222324252627public class Main &#123; public static void main(String[] args)&#123; long protime = System.currentTimeMillis(); Service&lt;Integer&gt; service1 = new Service&lt;&gt;(); SumTask task1 = new SumTask(); Data&lt;Integer&gt; result1 = service1.submitTask(task1); Service&lt;Integer&gt; service2 = new Service&lt;&gt;(); SumTask task2 = new SumTask(); Data&lt;Integer&gt; result2 = service2.submitTask(task2); Service&lt;Integer&gt; service3 = new Service&lt;&gt;(); SumTask task3 = new SumTask(); Data&lt;Integer&gt; result3 = service3.submitTask(task3); Integer sum = 0; sum += result1.getData(); sum += result2.getData(); sum += result3.getData(); long time = System.currentTimeMillis()-protime; System.out.println(&quot;总计需发工资：&quot;+sum+&quot; 耗时：&quot;+time); &#125;&#125; 执行结果： 由结果分析，我们已经实现了future模式，接下来分析下代码中到底做了什么。 首先Data类负责结果数据的接收，当真实结果数据未接收到的时候用getData方法将使主线程处于等待状态直到接收到真实结果数据。 Task主要是实现了每个部门的工资的结算工作，并返回每个部门的工资总额。 Service通过submitTask接收Task，并执行Task，返回执行结果。可以看到submitTask方法启动一个线程执行Task后，就直接返回一个结果（此时结果并没有真实的结果数据），等线程执行完将结果数据传递到data中，并唤醒其他线程（即Main中result.getData()来实现获取结果数据）。 Main主要是提交任务，接收任务处理结果以及任务耗时和工资结算统计工作。 细心的同学不难发现future模式跟生产者、消费者模式很类似，的确，future模式是生产者、消费者模式的扩展。其实在我们不断学习过程中会慢慢发现，很多看似高深的东西，也都是靠最基础的东西来实现和扩展的，只要基础打牢，在后续的学习将会简单很多。 本片文章到此也要结束了，后续还会对Java多线程方面的知识进行介绍以及总结，谢谢大家的支持！！！（文章中如有描述不明确或不正确的地方，欢迎大家批评指正，谢谢）。]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程（二）——Callable、Future和FutureTask]]></title>
    <url>%2F2017%2F08%2F11%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Callable%E3%80%81Future%E5%92%8CFutureTask%2F</url>
    <content type="text"><![CDATA[在上一章节我们介绍了Java实现多线程最常用的两种方式，但是那两种方式实现线程的时候并不能返回线程的执行结果。然而有些场景我们需要得到线程的执行结果，比如要计算每个部门的这个月的工资，然后进行总计（假设有n个部门，计算每个部门的工资需要花费m个小时，计算总计需要k个小时）。那么有以下两种方案供选择“： n个部门工资计算和总计都安排给一个人来做，需要花费n*m+k小时； 每个部门工资计算都分别安排给一个人来做（同时进行），最后一个人做统计工作，那么需要花费m+k小时即可； 方案一采用顺序执行的方式来做，需要花费的时间比较长；方案二采用执行并行的方式来做，在短时间内会花费更多的资源，但是节省了时间。方案一比较简单，在这里就不多赘述。让我们看下如何使用多线程的方式来实现方案二。 方案二的实现其实也很简单，无法是在多线程的基础上加上线程执行结果返回，Java中提供了Callable、Future和FutrueTask相关工具来协助我们实现，接下来就看下是如何实现的吧！ Callable+Future实现： 123456789101112//首先实现一个计算工资的Task类 并实现Callable接口 （线程返回结果类型即泛型填充类型） public class Task implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; System.out.println(&quot;部门：&quot;+ Thread.currentThread().getId()+&quot;正在计算工资&quot;); Random random = new Random(); Thread.sleep(2000);//模拟工资计算耗时 Integer sum = random.nextInt(100000); System.out.println(&quot;部门：&quot;+ Thread.currentThread().getId()+&quot;计算完成。结果：&quot;+sum); return sum; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839//执行任务计算Mainpublic class Main &#123; public static void main(String []args)&#123; //创建固定的线程数的线程池，不了解线程池的可以去了解下 ExecutorService pool = Executors.newFixedThreadPool(5); Task task1 = new Task(); Task task2 = new Task(); Task task3 = new Task(); Task task4 = new Task(); Task task5 = new Task(); long protime = System.currentTimeMillis(); //将五个部门的工资计算交由线程池中的线程执行 Future&lt;Integer&gt; result1 = pool.submit(task1); Future&lt;Integer&gt; result2 = pool.submit(task2); Future&lt;Integer&gt; result3 = pool.submit(task3); Future&lt;Integer&gt; result4 = pool.submit(task4); Future&lt;Integer&gt; result5 = pool.submit(task5); Integer sum = 0; //获取根据submit提交返回的类型为Future&lt;Integer&gt;类型的result获取线程执行结果（线程任务没执行完的话，在调用get方法的时会wait等待结果执行完成） try &#123; sum += result1.get(); sum += result2.get(); sum += result3.get(); sum += result4.get(); sum += result5.get(); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; long time = System.currentTimeMillis()-protime; System.out.println(&quot;总计需发工资：&quot;+sum+&quot; 耗时：&quot;+time); &#125;&#125; Callable+FutureTask实现： 123456789101112//首先实现一个计算工资的Task类 并实现Callable接口 （线程返回结果类型即泛型填充类型） public class Task implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; System.out.println(&quot;部门：&quot;+ Thread.currentThread().getId()+&quot;正在计算工资&quot;); Random random = new Random(); Thread.sleep(2000);//模拟工资计算耗时 Integer sum = random.nextInt(100000); System.out.println(&quot;部门：&quot;+ Thread.currentThread().getId()+&quot;计算完成。结果：&quot;+sum); return sum; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839public class Main &#123; public static void main(String []args)&#123; ExecutorService pool = Executors.newFixedThreadPool(5); /** FutureTask实现了RunnableFuture接口， RunnableFuture接口实现Runnable和Future接口 FutureTask相当于线程和结果的结合 */ FutureTask&lt;Integer&gt; futureTask1 = new FutureTask&lt;&gt;(new Task()); FutureTask&lt;Integer&gt; futureTask2 = new FutureTask&lt;&gt;(new Task()); FutureTask&lt;Integer&gt; futureTask3 = new FutureTask&lt;&gt;(new Task()); FutureTask&lt;Integer&gt; futureTask4 = new FutureTask&lt;&gt;(new Task()); FutureTask&lt;Integer&gt; futureTask5 = new FutureTask&lt;&gt;(new Task()); long protime = System.currentTimeMillis(); pool.submit(futureTask1); pool.submit(futureTask2); pool.submit(futureTask3); pool.submit(futureTask4); pool.submit(futureTask5); pool.shutdown(); Integer sum = 0; try &#123; sum += futureTask1.get(); sum += futureTask2.get(); sum += futureTask3.get(); sum += futureTask4.get(); sum += futureTask5.get(); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; long time = System.currentTimeMillis()-protime; System.out.println(&quot;总计需发工资：&quot;+sum+&quot; 耗时：&quot;+time); &#125;&#125; 两种方式实现的执行效果基本一样（排除随机等因素）：由结果分析，5个线程同时执行，大概计算2s后，相继计算出结果结果，耗时大概2s。 总结：future模式在Java多线程的用处还是蛮大的，尤其是在做并行计算的场景下。Java为我们提供了相关工具，所以实现难度也不大，加以练习就会很容易掌握。但是为了深刻理解future模式以及实现原理，下一章节会来手动实现future模式，敬请期待！！！（文章中如有描述不明确或不正确的地方，欢迎大家批评指正，谢谢）。]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程（一）——实现多线程的两种方式]]></title>
    <url>%2F2017%2F07%2F26%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[java实现多线程的常用方式有两种：继承Thread类、实现Runnable接口实现run方法。 继承Thread实现方式： 1234567891011121314151617public class ThreadTest extends Thread&#123; private int ticket = 100; public void run() &#123; while(ticket &gt; 0)&#123; ticket--; System.out.println(Thread.currentThread().getName()+&quot;tickets:&quot;+ticket); &#125; &#125; public static void main(String[] args)&#123; ThreadTest threadTest = new ThreadTest(); threadTest.start(); System.out.println(&quot;主线程执行结束！&quot;); &#125;&#125; 实现Runnable实现方式： 12345678910111213141516171819public class RunableTest implements Runnable&#123; private int ticket = 100; @Override public void run() &#123; while(ticket &gt; 0)&#123; ticket--; System.out.println(Thread.currentThread().getName()+&quot;tickets:&quot;+ticket); &#125; &#125; public static void main(String[] args)&#123; RunableTest runableTest = new RunableTest(); Thread testThread = new Thread(runableTest); testThread.start(); System.out.println(&quot;主线程结束！&quot;); &#125;&#125; 可以看出这两种方式实现多线程的方式非常相似，那它们之间有什么区别呢？设想个场景，火车站有100张票，有4个窗口进行售票，如何实现4个窗口共享100张票呢？ 案例一： 1234567891011121314151617181920212223public class ThreadTest extends Thread&#123; private int tickets = 100; public void run() &#123; while(tickets &gt; 0)&#123; tickets--; System.out.println(Thread.currentThread().getName()+&quot;tickets:&quot;+tickets); &#125; &#125; public static void main(String[] args)&#123; ThreadTest threadTest1 = new ThreadTest(); ThreadTest threadTest2 = new ThreadTest(); ThreadTest threadTest3 = new ThreadTest(); ThreadTest threadTest4 = new ThreadTest(); threadTest1.start(); threadTest2.start(); threadTest3.start(); threadTest4.start(); System.out.println(&quot;主线程执行结束！&quot;); &#125;&#125; 不难看出“案例一”没有共享tickets资源，而是每个线程独自创建了一个tickets资源，就相当于每个窗口都有100张票进行销售。 案例二： 12345678910111213141516171819202122232425public class ThreadTest extends Thread&#123; private static int tickets = 100; public void run() &#123; while(tickets &gt; 0)&#123; tickets--; System.out.println(Thread.currentThread().getName()+&quot;tickets:&quot;+tickets); &#125; &#125; public static void main(String[] args)&#123; ThreadTest threadTest1 = new ThreadTest(); ThreadTest threadTest2 = new ThreadTest(); ThreadTest threadTest3 = new ThreadTest(); ThreadTest threadTest4 = new ThreadTest(); threadTest1.start(); threadTest2.start(); threadTest3.start(); threadTest4.start(); System.out.println(&quot;主线程执行结束！&quot;); &#125;&#125; “案例二”把成员变量用static修饰后，tickets属于ThreadTest类，不再属于ThreadTest创建的对象，这样就实现了多个线程对统一资源的共享。 案例三： 123456789101112131415161718192021public class ThreadTest extends Thread&#123; private int tickets = 100; public void run() &#123; while(tickets &gt; 0)&#123; tickets--; System.out.println(Thread.currentThread().getName()+&quot;tickets:&quot;+tickets); &#125; &#125; public static void main(String[] args)&#123; ThreadTest threadTest1 = new ThreadTest(); threadTest1.start(); threadTest1.start(); threadTest1.start(); threadTest1.start(); System.out.println(&quot;主线程执行结束！&quot;); &#125;&#125; “案例三”创建了一个ThreadTest对象启动了4次，系统它会启动4个线程来处理tickets，通过结果分析并没有创建4个线程处理，仅仅创建了一个线程。可见一个线程对象只能启动一个线程，无论调用几次start方法，都只是一个线程在执行。 案例四： 123456789101112131415161718192021222324252627public class RunableTest implements Runnable&#123; private int tickets = 100; @Override public void run() &#123; while(tickets &gt; 0)&#123; tickets--; System.out.println(Thread.currentThread().getName()+&quot;tickets:&quot;+tickets); &#125; &#125; public static void main(String args[])&#123; RunableTest runableTest = new RunableTest(); Thread thread1 = new Thread(runableTest); Thread thread2 = new Thread(runableTest); Thread thread3 = new Thread(runableTest); Thread thread4 = new Thread(runableTest); thread1.start(); thread2.start(); thread3.start(); thread4.start(); System.out.println(&quot;主线程执行结束！&quot;); &#125;&#125; “案例四”创建了四个线程，每个线程都调用runableTest对象的run方法，也就是说每个线程同时共享了runableTest对象中的tickets成员变量。 那么继承Thread和实现Runnable接口实现多线程有什么区别呢？ 由以上几个案例可见，即使实现Runnable接口实现多线程，也是要通过创建Thread来启动实现的，所以使用继承Thread方式实现多线程在代码上可以简化。 Java不像C++支持多继承，所以说在一个类已经有个父类的时候就无法继承Thread来实现多线程，所以实现Runnable接口在扩展性上要比继承Thread方式实现好。 分析案例不难看出，在多个线程同时执行一块代码区域的时候使用实现Runnable接口的方式更加合适。把虚拟CPU（线程）同程序的代码，数据有效的分离，较好地体现了面向对象的设计思想。 备注：以上案例并不能实现多线程线程安全的共享tickets资源，案例的目标是为了描述两种实现多线程的方式是如何实现共享资源的（非线程安全）。如果想了解如何保证资源线程安全的被多个线程处理，请持续关注笔者的《Java多线程》系列相关博客，谢谢！]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis Generator 使用（Maven插件）]]></title>
    <url>%2F2017%2F06%2F21%2FMybatis-Generator-%E4%BD%BF%E7%94%A8%EF%BC%88Maven%E6%8F%92%E4%BB%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近搭一个项目后台框架，项目采用SSM框架，项目比较紧急，所以选用Mybatis Generator来自动生成XML、Dao和Model来减少重复的工作。 Mybatis Generator有以下两种使用方法： 直接下载相关jar包 下载地址：https://github.com/mybatis/generator/releases 使用maven中的generator插件 为了保证项目方便管理，所以采用了Maven插件的方式使用Mybatis Generator来自动生成代码。 导入Mybatis Generator插件 在pom.xml增加以下插件：12345678910111213141516171819&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;goals&gt; &lt;goal&gt; generate &lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; 配置Mybatis Generator插件 生成的xml存放在src\main\resources路径下 ：&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot; &gt;&lt;generatorConfiguration&gt; &lt;!-- java连接数据库jar所在路径 --&gt; &lt;classPathEntry location=&quot;E:\OpenCode\weixin\src\main\resources\mysql-connector-java-5.1.30.jar&quot; /&gt; &lt;context id=&quot;context1&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!-- 数据库连接信息 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://120.25.89.67:3306/db_iyiqiba&quot; userId=&quot;ZSQ1&quot; password=&quot;123&quot; /&gt; &lt;!-- mybatis里专门用来处理NUMERIC和DECIMAL类型的策略 --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;true&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成model类的包 和路径 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.iyiqiba.dao.model&quot; targetProject=&quot;src\main\java&quot; /&gt; &lt;!-- 生成Mapper.xml 所在路径下面配置路径为src\main\resources\ibatis-generator --&gt; &lt;sqlMapGenerator targetPackage=&quot;ibatis-generator&quot; targetProject=&quot;src\main\resources&quot; /&gt; &lt;!-- 生成Dao接口所在包和文件路径 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.iyiqiba.dao&quot; targetProject=&quot;src\main\java&quot;&gt; &lt;/javaClientGenerator&gt; &lt;!-- tableName：表名 domainObjectName：对应数据库表的model类名称--&gt; &lt;table tableName=&quot;tb_student_base_info&quot; domainObjectName=&quot;StudentBaseInfo&quot;&gt; &lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;tb_student_detaill_info&quot; domainObjectName=&quot;StudentDetaillInfo&quot; &gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;tb_business_base_info&quot; domainObjectName=&quot;BusinessBaseInfo&quot; &gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;tb_business_detaill_info&quot; domainObjectName=&quot;BusinessDetaillInfo&quot; &gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;tb_third_user_info&quot; domainObjectName=&quot;ThirdUserInfo&quot;&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;tb_activity_comment&quot; domainObjectName=&quot;ActivityComment&quot;&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;tb_activity_info&quot; domainObjectName=&quot;ActivityInfo&quot;&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;tb_activity_join&quot; domainObjectName=&quot;ActivityJoin&quot;&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;tb_activity_mark&quot; domainObjectName=&quot;ActivityMark&quot; &gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;tb_address_info&quot; domainObjectName=&quot;AddressInfo&quot;&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;tb_activity_placard&quot; domainObjectName=&quot;ActivityPlacard&quot; &gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;tb_kind_info&quot; domainObjectName=&quot;KindInfo&quot; &gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 这里并没有屏蔽Example，很多人不想生成Example可能感觉比较杂乱。可以通过在&lt;table/&gt;中配置enableUpdateByExample等信息来去掉Example。 1234 &lt;table tableName=&quot;tb_business_base_info&quot; domainObjectName=&quot;BusinessBaseInfo&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot;enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt; &lt;/table&gt; mybatis generator目标就是减少Dao层的工作量，针对这一点建议保留Example，如果不保留可能还需要写更多的动态SQL才能完成工作，这样代码自动生成工具的价值就体现不出来了。 因为自动生成代码的时候会覆盖文件，所以建议把手写的动态SQL和自动生成的分成2个Mapper.xml文件，这样数据库添加字段或有其他修改的时候重新生成Mapper.xml不会影响我们手写的动态SQL。 执行maven命令 右键项目–RunAS-Maven build-输入mybatis-generator:generate指令 点击Run 即可成功生成相关代码。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具类（一）-----微信工具类]]></title>
    <url>%2F2017%2F06%2F19%2F%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%88%E4%B8%80%EF%BC%89-%E5%BE%AE%E4%BF%A1%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[前些天做微信授权登录用到了一些关于调用微信接口的东西，写了个工具类分享给大家，如有问题欢迎大家批评指正！！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153package com.iyiqiba.utility;import java.io.IOException;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.alibaba.fastjson.JSONObject;import com.iyiqiba.common.WChartUser;import com.iyiqiba.common.OAuthAccessToken;/** * 微信工具类 * @author ZSQ 2017年6月4日20:49:34 * */public class WChartUtils &#123; private static Logger log = LoggerFactory.getLogger(WChartUtils.class); public final static String APPID = &quot;wx6a42b00945e04c&quot;; public final static String APPSECRET = &quot;05e78940a491423c47185e7ccb8ee&quot;; //获取用户详细信息 public final static String SCOPE_INFO = &quot;snsapi_userinfo&quot;; //近获取用户open_id public final static String SCOPE_BASE = &quot;snsapi_base&quot;; //微信请求接口地址 //获取access_token 接口地址 Get public final static String ACCESS_TOKEN_URL = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET&quot;; //获取网页授权登录access_token 接口地址Get public final static String OAUTH_ACCESS_TOKEN_URL = &quot;https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code&quot;; //获取授权登录用户信息 接口地址Get public final static String OAUTH_WCHAT_USER_URL = &quot;https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN&quot;; public final static String OAUTH_LOGIN_URL = &quot;https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect&quot;; //access_token有效时间 时间有时间是7200 为了防止延时导致获取access_token的间断 public static long expires_in = 7100; //上次获取access_token时间 private static Long lastGetAccessTokenTime = 0L; //当前access_token值 private static String access_token = null; /*** * 获取access_token * @return access_token * @throws IOException */ public static String getAccessToken() throws IOException&#123; if (access_token == null) &#123;//当前没有获取access_token access_token = refreshAccessToken(); &#125;else &#123;//已经获取过access_token Long curTime = System.currentTimeMillis(); if ((curTime-lastGetAccessTokenTime)/1000 &gt;= expires_in) &#123; access_token = refreshAccessToken(); &#125; &#125; return access_token; &#125; /*** * 刷新access_token * @return access_token * @throws IOException */ public static String refreshAccessToken() throws IOException&#123; lastGetAccessTokenTime = System.currentTimeMillis(); String url = ACCESS_TOKEN_URL.replace(&quot;APPID&quot;, APPID).replace(&quot;APPSECRET&quot;, APPSECRET); String result = HttpsRequest.sendGet(url); JSONObject json = JSONObject.parseObject(result); String token = (String) json.get(&quot;access_token&quot;); if (token == null) &#123; String errorCode = (String) json.get(&quot;errcode&quot;); String errorMsg = (String) json.get(&quot;errmsg&quot;); log.error(&quot;获取access_token失败:错误代码：&quot; + errorCode + &quot;错误信息：&quot; + errorMsg); &#125; return token; &#125; /** * 获取授权登录access_token * @param code * @return * @throws IOException */ public static OAuthAccessToken getOAuthAccessToken(String code) throws IOException&#123; String url = OAUTH_ACCESS_TOKEN_URL.replace(&quot;APPID&quot;, APPID).replace(&quot;SECRET&quot;, APPSECRET).replace(&quot;CODE&quot;, code); String result = HttpsRequest.sendGet(url); JSONObject json= JSONObject.parseObject(result); String token = json.getString(&quot;access_token&quot;); if(token == null)&#123; String errorCode = json.getString(&quot;errcode&quot;); String errorMsg = json.getString(&quot;errmsg&quot;); System.out.println(json.toString()); log.error(&quot;获取授权登录access_token失败:错误代码：&quot; + errorCode + &quot;错误信息：&quot; + errorMsg); return null; &#125; OAuthAccessToken accessToken = (OAuthAccessToken) JSONObject.parseObject(result, OAuthAccessToken.class); return accessToken; &#125; /** * 获取用户信息 * @return * @throws IOException */ public static WChartUser getOAuthUserInfo(String code) throws IOException&#123; OAuthAccessToken accessToken = WChartUtils.getOAuthAccessToken(code); if (accessToken == null) &#123; return null; &#125; String token = accessToken.getAccess_token(); String openid = accessToken.getOpenid(); String url = OAUTH_WCHAT_USER_URL.replace(&quot;ACCESS_TOKEN&quot;, token).replace(&quot;OPENID&quot;, openid); String result = HttpsRequest.sendGet(url); JSONObject jsonObject = JSONObject.parseObject(result); openid = jsonObject.getString(&quot;openid&quot;); if(openid == null)&#123; String errorCode = jsonObject.getString(&quot;errcode&quot;); String errorMsg = jsonObject.getString(&quot;errmsg&quot;); System.out.println(jsonObject.toString()); log.error(&quot;获取access_token失败:错误代码：&quot; + errorCode + &quot;错误信息：&quot; + errorMsg); return null; &#125; WChartUser user = JSONObject.parseObject(result, WChartUser.class); return user; &#125; public static String getOAuthLoginUrl(String redirectUrl, String scope)&#123; return OAUTH_LOGIN_URL.replace(&quot;APPID&quot;, APPID).replace(&quot;REDIRECT_URI&quot;, redirectUrl) .replace(&quot;SCOPE&quot;, scope); &#125; public static void main(String []args) throws Exception&#123; //WChartUtils.getOAuthUserInfo(&quot;123&quot;);// String result = &quot;&#123; \&quot;access_token\&quot;:\&quot;ACCESS_TOKEN\&quot;, \&quot;expires_in\&quot;:7200, \&quot;refresh_token\&quot;:\&quot;REFRESH_TOKEN\&quot;, \&quot;openid\&quot;:\&quot;OPENID\&quot;, \&quot;scope\&quot;:\&quot;SCOPE\&quot; &#125;&quot;;// System.out.println(result);// OAuthAccessToken accessToken = JSONObject.parseObject(result, OAuthAccessToken.class);// System.out.println(accessToken.getOpenid());// System.out.println(accessToken.getAccess_token()); System.out.println(WChartUtils.getAccessToken()); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>工具类</tag>
      </tags>
  </entry>
</search>
